<!DOCTYPE html>
<html>
  <head>
    <title>three.js css3d - periodic table (Google Sheets)</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      a {
        color: #8ff;
      }
      #menu {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
      }

      .element {
        width: 120px;
        height: 160px;
        box-shadow: 0px 0px 12px rgba(0, 255, 255, 0.5);
        border: 1px solid rgba(127, 255, 255, 0.25);
        font-family: Helvetica, sans-serif;
        text-align: center;
        line-height: normal;
        cursor: default;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }

      .element:hover {
        box-shadow: 0px 0px 12px rgba(0, 255, 255, 0.75);
        border: 1px solid rgba(127, 255, 255, 0.75);
      }

      .element .number {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.5);
      }

      .element .name {
        font-size: 20px;
        font-weight: bold;
        color: rgba(255, 255, 255, 0.9);
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        margin-bottom: 5px;
      }

      .element .networth {
        font-size: 14px;
        font-weight: bold;
        color: rgba(255, 255, 255, 0.75);
      }

      .element .details {
        font-size: 10px;
        color: rgba(127, 255, 255, 0.75);
        margin-top: 5px;
      }

      button {
        color: rgba(127, 255, 255, 0.75);
        background: transparent;
        outline: 1px solid rgba(127, 255, 255, 0.75);
        border: 0px;
        padding: 5px 10px;
        cursor: pointer;
      }

      button:hover {
        background-color: rgba(0, 255, 255, 0.5);
      }
      button:active {
        color: #000000;
        background-color: rgba(0, 255, 255, 0.75);
      }

      /* Login Overlay */
      #login-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
      }
    </style>
    <!-- Google Identity Services -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
  </head>
  <body>
    <!-- LOGIN SCREEN -->
    <div id="login-overlay">
      <h1>Three.js Data Visualizer</h1>
      <p>Please sign in to load data from Google Sheets</p>
      <div
        id="g_id_onload"
        data-client_id="661362557034-blcndd2cpt3scd281mls1ebsvu7nau82.apps.googleusercontent.com"
        data-context="signin"
        data-ux_mode="popup"
        data-callback="handleCredentialResponse"
        data-auto_prompt="false"
      ></div>
      <div
        class="g_id_signin"
        data-type="standard"
        data-shape="rectangular"
        data-theme="outline"
        data-text="signin_with"
        data-size="large"
        data-logo_alignment="left"
      ></div>
    </div>

    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
      css3d - periodic table
    </div>
    <div id="container"></div>
    <div id="menu">
      <button id="table">TABLE</button>
      <button id="sphere">SPHERE</button>
      <button id="helix">HELIX</button>
      <button id="grid">GRID</button>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script>
      // GLOBAL CONFIGURATION
      const SHEET_ID = "YOUR_GOOGLE_SHEET_ID_HERE";
      const API_KEY = "YOUR_OPTIONAL_API_KEY_IF_NEEDED"; // Usually accessible via Token
      let accessToken = null;

      // Callback function for Google Login
      function handleCredentialResponse(response) {
        // New Google Identity Services returns a JWT credential.
        // However, to access Sheets API, we usually need an access token via OAuth flow.
        // For simplicity in this assignment context, we trigger the Token Client flow immediately after basic sign-in,
        // or we use the Token Client directly.

        // Let's initialize the Token Client
        tokenClient.requestAccessToken();
      }

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;

      function gapiLoaded() {
        gapi.load("client", initializeGapiClient);
      }

      async function initializeGapiClient() {
        // Load Sheets API discovery document
        await gapi.client.init({
          // apiKey: API_KEY, // Optional if strictly using OAuth
          discoveryDocs: [
            "https://sheets.googleapis.com/$discovery/rest?version=v4",
          ],
        });
        gapiInited = true;
        checkAuth();
      }

      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id:
            "661362557034-blcndd2cpt3scd281mls1ebsvu7nau82.apps.googleusercontent.com", // PASTE CLIENT ID HERE TOO
          scope: "https://www.googleapis.com/auth/spreadsheets.readonly",
          callback: "", // defined later
        });
        gisInited = true;
        checkAuth();
      }

      function checkAuth() {
        if (gapiInited && gisInited) {
          // Ready to request token
          document.getElementById("login-overlay").style.display = "flex";
        }
      }

      // We need to load the GAPI script dynamically for Sheets API access
      const script = document.createElement("script");
      script.src = "https://apis.google.com/js/api.js";
      script.onload = () => gapi.load("client", initializeGapiClient);
      document.head.appendChild(script);

      const script2 = document.createElement("script");
      script2.src = "https://accounts.google.com/gsi/client";
      script2.onload = gisLoaded;
      document.head.appendChild(script2);

      // Override the login button logic to use Token Client for API access
      window.handleCredentialResponse = (response) => {
        // Decode JWT if you need user info, but we need Access Token for Sheets
      };

      // UI trigger
      document.querySelector(".g_id_signin").addEventListener("click", () => {
        tokenClient.callback = async (resp) => {
          if (resp.error !== undefined) {
            throw resp;
          }
          document.getElementById("login-overlay").style.display = "none";
          await fetchData();
        };
        tokenClient.requestAccessToken({ prompt: "consent" });
      });

      async function fetchData() {
        try {
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: SHEET_ID,
            range: "Sheet1!A2:E201", // Fetch top 200 rows approx
          });

          const data = response.result.values;
          if (data && data.length > 0) {
            // Dispatch event to main module
            window.dispatchEvent(
              new CustomEvent("dataLoaded", { detail: data })
            );
          }
        } catch (err) {
          console.error("Error fetching sheets", err);
          alert("Error fetching data. Check console.");
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import TWEEN from "three/addons/libs/tween.module.js";
      import { TrackballControls } from "three/addons/controls/TrackballControls.js";
      import {
        CSS3DRenderer,
        CSS3DObject,
      } from "three/addons/renderers/CSS3DRenderer.js";

      let camera, scene, renderer;
      let controls;
      const objects = [];
      const targets = { table: [], sphere: [], helix: [], grid: [] };

      // Wait for data from the Google Script
      window.addEventListener("dataLoaded", (e) => {
        const sheetData = e.detail;
        init(sheetData);
        animate();
      });

      function parseNetWorth(val) {
        if (!val) return 0;
        // Remove symbols like $ and ,
        return parseFloat(val.toString().replace(/[^0-9.-]+/g, ""));
      }

      function getBackgroundColor(netWorth) {
        const val = parseNetWorth(netWorth);
        if (val > 200000) return "rgba(0, 128, 0, 0.75)"; // Green
        if (val > 100000) return "rgba(255, 165, 0, 0.75)"; // Orange
        return "rgba(255, 0, 0, 0.75)"; // Red
      }

      function init(data) {
        camera = new THREE.PerspectiveCamera(
          40,
          window.innerWidth / window.innerHeight,
          1,
          10000
        );
        camera.position.z = 3000;

        scene = new THREE.Scene();

        // 1. CREATE OBJECTS FROM DATA
        for (let i = 0; i < data.length; i++) {
          // Assuming Sheet Columns: [0] Name, [1] Net Worth, [2] Details/Country
          const rowData = data[i];
          const nameText = rowData[0] || "N/A";
          const netWorthText = rowData[1] || "$0";
          const detailsText = rowData[2] || "";

          const element = document.createElement("div");
          element.className = "element";
          // COLOR LOGIC: Red <100k, Orange >100k, Green >200k
          element.style.backgroundColor = getBackgroundColor(netWorthText);

          const number = document.createElement("div");
          number.className = "number";
          number.textContent = i + 1;
          element.appendChild(number);

          const symbol = document.createElement("div");
          symbol.className = "name";
          symbol.textContent = nameText;
          element.appendChild(symbol);

          const details = document.createElement("div");
          details.className = "networth";
          details.innerHTML = netWorthText;
          element.appendChild(details);

          const extra = document.createElement("div");
          extra.className = "details";
          extra.textContent = detailsText;
          element.appendChild(extra);

          const objectCSS = new CSS3DObject(element);
          objectCSS.position.x = Math.random() * 4000 - 2000;
          objectCSS.position.y = Math.random() * 4000 - 2000;
          objectCSS.position.z = Math.random() * 4000 - 2000;
          scene.add(objectCSS);

          objects.push(objectCSS);
        }

        // 2. DEFINE LAYOUTS

        // --- TABLE (20 columns x 10 rows) ---
        // Width of cell approx 140, Height 180
        for (let i = 0; i < objects.length; i++) {
          const object = new THREE.Object3D();

          const col = i % 20;
          const row = Math.floor(i / 20);

          object.position.x = col * 140 - 1330;
          object.position.y = -(row * 180) + 900;

          targets.table.push(object);
        }

        // --- SPHERE (Standard) ---
        const vector = new THREE.Vector3();
        for (let i = 0, l = objects.length; i < l; i++) {
          const phi = Math.acos(-1 + (2 * i) / l);
          const theta = Math.sqrt(l * Math.PI) * phi;
          const object = new THREE.Object3D();
          object.position.setFromSphericalCoords(800, phi, theta);
          vector.copy(object.position).multiplyScalar(2);
          object.lookAt(vector);
          targets.sphere.push(object);
        }

        // --- DOUBLE HELIX ---
        for (let i = 0, l = objects.length; i < l; i++) {
          // To create a double helix, we split the index.
          // Even indices go to one strand, Odd to the other (offset by PI)
          const phi = (i % 2) * Math.PI;
          // We advance height slower since we are splitting particles between two strands
          const heightIndex = Math.floor(i / 2);

          const theta = heightIndex * 0.175 + phi;
          const y = -(heightIndex * 15) + 750;

          const object = new THREE.Object3D();
          object.position.setFromCylindricalCoords(900, theta, y);

          vector.x = object.position.x * 2;
          vector.y = object.position.y;
          vector.z = object.position.z * 2;
          object.lookAt(vector);
          targets.helix.push(object);
        }

        // --- GRID (5x4x10) ---
        // 5 width (x), 4 height (y), 10 depth (z)
        for (let i = 0; i < objects.length; i++) {
          const object = new THREE.Object3D();

          // x: i % 5
          // y: (i / 5) % 4
          // z: i / 20

          object.position.x = (i % 5) * 400 - 800;
          object.position.y = -(Math.floor(i / 5) % 4) * 400 + 800;
          object.position.z = Math.floor(i / 20) * 1000 - 2000;

          targets.grid.push(object);
        }

        // RENDERER SETUP
        renderer = new CSS3DRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        // CONTROLS
        controls = new TrackballControls(camera, renderer.domElement);
        controls.minDistance = 500;
        controls.maxDistance = 6000;
        controls.addEventListener("change", render);

        // BUTTON LISTENERS
        const buttonTable = document.getElementById("table");
        buttonTable.addEventListener("click", function () {
          transform(targets.table, 2000);
        });

        const buttonSphere = document.getElementById("sphere");
        buttonSphere.addEventListener("click", function () {
          transform(targets.sphere, 2000);
        });

        const buttonHelix = document.getElementById("helix");
        buttonHelix.addEventListener("click", function () {
          transform(targets.helix, 2000);
        });

        const buttonGrid = document.getElementById("grid");
        buttonGrid.addEventListener("click", function () {
          transform(targets.grid, 2000);
        });

        transform(targets.table, 2000);

        window.addEventListener("resize", onWindowResize);
      }

      function transform(targets, duration) {
        TWEEN.removeAll();
        for (let i = 0; i < objects.length; i++) {
          const object = objects[i];
          const target = targets[i];
          if (target) {
            new TWEEN.Tween(object.position)
              .to(
                {
                  x: target.position.x,
                  y: target.position.y,
                  z: target.position.z,
                },
                Math.random() * duration + duration
              )
              .easing(TWEEN.Easing.Exponential.InOut)
              .start();
            new TWEEN.Tween(object.rotation)
              .to(
                {
                  x: target.rotation.x,
                  y: target.rotation.y,
                  z: target.rotation.z,
                },
                Math.random() * duration + duration
              )
              .easing(TWEEN.Easing.Exponential.InOut)
              .start();
          }
        }
        new TWEEN.Tween(this)
          .to({}, duration * 2)
          .onUpdate(render)
          .start();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        render();
      }

      function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        controls.update();
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
